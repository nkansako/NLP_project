import nlp_config as config
import nlp_helpers as helpers
import preprocessing
import fuzzy
import csv

# constants
results_path = 'results/8/'


# TASK DESCRIPTION
# 8. Compare the phonetic of starting word and ending word of each line of the poem.
# Use the “Fuzzy” library in python to generate the character string that identifies phonetically similar words,
# and then use edit distance to compute the phonetic similarity between two words.
# Leave the size of the generated string open.
# The distance between the phonetic generated vectors corresponding to starting/ending word is generated like this:
# Assume L1 is the first word phonetic string, and L2 is the second word phonetic string generated by Fuzzy library.
# Then the phonetic association Sim(L1,L2)= 2*S/ (length(L1)+length(L2)) where S is the length of the largest substring,
# which is common to both L1 and L2.
# Calculate the value of Sim(L1,L2) for each line of the poem and size the result in excel file.
# Find out whether some curve fitting (polynomial, exponential or zipf can be fitted to the data).
# Motivate your answer and display appropriate plotting.


def phonetic(book):
    phonetics = []
    for title, chapter in book.items():
        for line in chapter:
            first = line[0]
            last = line[1]
            s1 = fuzzy.Soundex(len(first))
            s2 = fuzzy.Soundex(len(last))
            print(first, last)  # show what happens
            l1 = s1(first)  # These fail with non ascii characters
            l2 = s2(last)
            print(l1, l2)

            S = len(largest_common_substring(l1, l2, len(l1), len(l2)))
            try:
                similarity = 2 * S / (len(l1) + len(l2))
            except ZeroDivisionError as e:
                similarity = 0
            phonetics.append(similarity)


def largest_common_substring(X, Y, m, n):
    LCSuff = [[0 for i in range(n + 1)]
              for j in range(m + 1)]

    # To store length of the
    # longest common substring
    length = 0

    # To store the index of the cell
    # which contains the maximum value.
    # This cell's index helps in building
    # up the longest common substring
    # from right to left.
    row, col = 0, 0

    # Following steps build LCSuff[m+1][n+1]
    # in bottom up fashion.
    for i in range(m + 1):
        for j in range(n + 1):
            if i == 0 or j == 0:
                LCSuff[i][j] = 0
            elif X[i - 1] == Y[j - 1]:
                LCSuff[i][j] = LCSuff[i - 1][j - 1] + 1
                if length < LCSuff[i][j]:
                    length = LCSuff[i][j]
                    row = i
                    col = j
            else:
                LCSuff[i][j] = 0

    # if true, then no common substring exists
    if length == 0:
        print("No Common Substring")
        return ""

    # allocate space for the longest
    # common substring
    resultStr = ['0'] * length

    # traverse up diagonally form the
    # (row, col) cell until LCSuff[row][col] != 0
    while LCSuff[row][col] != 0:
        length -= 1
        resultStr[length] = X[row - 1]  # or Y[col-1]

        # move diagonally up to previous cell
        row -= 1
        col -= 1

    # required longest common substring
    # print(''.join(resultStr))

    return ''.join(resultStr)


def task8():

    raw_books = helpers.getBooks()

    for book_ref, raw_book in raw_books.items():

        title_ = config.books[book_ref]['title']

        chapters = preprocessing.preprocess(raw_book)

        phonetic(chapters)


if __name__ == "__main__":
    task8()
